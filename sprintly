#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import sys, os, locale, urllib, urllib2, json, subprocess, re, string, logging, os, tempfile
from curses import setupterm, tigetstr, tigetnum, tparm
from time import time
from argparse import ArgumentParser
from subprocess import call

# force utf-8 encoding
reload(sys)
sys.setdefaultencoding('utf-8')

logging.basicConfig()
logger = logging.getLogger(__name__)

# constants
CONFIG_VERSION = '2.1'
SPRINTLY_NAME = 'sprintly'
SPRINTLY_DIR = '/usr/local/bin/' if os.name != 'nt' else os.environ["PYTHONHOME"]+'/Scripts/'
SPRINTLY_SOURCE_URL = 'https://raw.github.com/bumboarder6/Sprintly-GitHub/master/sprintly'

# non-editable constants
SPRINTLY_PATH = SPRINTLY_DIR + SPRINTLY_NAME

# tty colors
DEFAULT = '\x1b[39m'
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, LIGHT_GREY = [('\x1b[%dm' % (30 + i)) for i in range(8)]
GREY, BRIGHT_RED, BRIGHT_GREEN, BRIGHT_YELLOW, BRIGHT_BLUE, BRIGHT_MAGENTA, BRIGHT_CYAN, WHITE = [('\x1b[%dm' % (90 + i)) for i in range(8)]
RESET, NORMAL, BOLD, DIM, UNDERLINE, INVERT, HIDDEN = [('\x1b[%dm' % i) for i in (0, 22, 1, 2, 4, 7, 8)]
ATTRS = {
    'DEFAULT': DEFAULT,
    'BLACK': BLACK, 'RED': RED, 'GREEN': GREEN, 'YELLOW': YELLOW, 'BLUE': BLUE, 'MAGENTA': MAGENTA, 'CYAN': CYAN, 'LIGHT_GREY': LIGHT_GREY,
    'GREY': GREY, 'BRIGHT_RED': BRIGHT_RED, 'BRIGHT_GREEN': BRIGHT_GREEN, 'BRIGHT_YELLOW': BRIGHT_YELLOW, 'BRIGHT_BLUE': BRIGHT_BLUE, 'BRIGHT_MAGENTA': BRIGHT_MAGENTA, 'BRIGHT_CYAN': BRIGHT_CYAN, 'WHITE': WHITE,
    'RESET': RESET, 'NORMAL': NORMAL, 'BOLD': BOLD, 'DIM': DIM, 'UNDERLINE': UNDERLINE, 'INVERT': INVERT, 'HIDDEN': HIDDEN
}

ITEM_COLORS = {
    'story': 'GREEN',
    'task': 'GREY',
    'defect': 'RED',
    'test': 'CYAN'
}

ITEM_STATUSES = {
    'someday': 'Someday',
    'backlog': "Backlog",
    'in-progress': "In Progress",
    'completed': "Completed",
    'accepted': "Accepted",
}

ITEM_SCORES = {
    '~': 'No Score',
    'S': 'Small Matter',
    'M': 'Eh Kinda Hard',
    'L': 'Breakin a sweat',
    'XL': 'WTF'
}

EDITOR = os.environ.get('EDITOR', 'emacs')


INIT_MSG = '# Please enter your %s below, any commented lines will be removed'

def messageFromEditor(usage):
    """ Spawns an editor with the init message in it then returns the contents
        after it is finished and saved, returns None if there was an empty file """
    tmp = tempfile.NamedTemporaryFile(suffix=".tmp", delete=False)
    tmp.write(INIT_MSG % (usage,))
    tmp.flush()
    name = tmp.name
    tmp.close()
    call([EDITOR, name])
    tmp = open(name, 'r')
    data = tmp.read()
    tmp.close()
    os.remove(name)
    return re.sub('^\s*#.*?$', '', data, flags=re.M | re.I).strip()


class SprintlyTool:
    """
    A command line tool for displaying your stories, tasks, tests, and defects
    from Sprint.ly.
    """

    def __init__(self, term_stream=sys.stdout):
        """
        Initialize instance variables.
        """

        # Set up terminal
        locale.setlocale(locale.LC_ALL, '')
        self._encoding = locale.getpreferredencoding()

        self._term = term_stream or sys.__stdout__
        self._is_tty = False
        self._has_color = False
        self._cols = 80

        if hasattr(term_stream, "isatty") and term_stream.isatty():
            try:
                setupterm()
                self._is_tty = True
                self._has_color = tigetnum('colors') > 2
                self._cols = tigetnum('cols')
            except:
                pass
        else:
            try:
                (_, columns) = os.popen('stty size', 'r').read().split()
                self._cols = int(columns)
            except:
                pass

        self._config = {}
        self._sprintlyDirectoryPath = None
        self._sprintlyConfigPath = None
        self.parser = None

    def run(self, scr=None):
        """
        Application flow.
        """
        
        # self.cprint('${BLACK} Black ${RED} RED ${GREEN} GREEN ${YELLOW} YELLOW ${BLUE} BLUE ${MAGENTA} MAGENTA ${CYAN} CYAN ${LIGHT_GREY} LIGHT_GREY ${GREY} GREY ${BRIGHT_RED} BRIGHT_RED ${BRIGHT_GREEN} BRIGHT_GREEN ${BRIGHT_YELLOW} BRIGHT_YELLOW ${BRIGHT_BLUE} BRIGHT_BLUE ${BRIGHT_MAGENTA} BRIGHT_MAGENTA ${BRIGHT_CYAN} BRIGHT_CYAN ${WHITE} WHITE')
        
        try:
            self.initialize()
            
            if len(sys.argv) == 1:
                self._items_action()
                return
            
            description = 'By default, your Sprint.ly items will be shown.'
            
            parser = ArgumentParser(description=description)
            subparsers = parser.add_subparsers(dest='action_name')
            install_p = subparsers.add_parser('install', help='install this tool.')
            install_p.set_defaults(func=self._installAndInit)

            update_p = subparsers.add_parser('update', help='update this tool.')
            update_p.set_defaults(func=self._updateAndInit)

            update_config_p = subparsers.add_parser('update-config', help='edit configuration.')
            update_config_p.set_defaults(func=self._initAndUpdateConfig)

            users_p = subparsers.add_parser('users', help='Get/set user information. Lists users by default.')
            users_p.set_defaults(func=self._users_action)
            users_p.add_argument('-p', '--product', action='store_true', help='List users by the product they work on.')

            users_p_arg_group = users_p.add_mutually_exclusive_group()
            users_p_arg_group.add_argument('-l', '--list', action='store_true', help='List users.')

            items_p = subparsers.add_parser('items', help='Lists your items by default')
            items_p.set_defaults(func=self._items_action)
            items_p.add_argument('-u', '--user', default=None, help='Specify a user (by user ID). Defaults to you.')
            items_p.add_argument('-c', '--completed', action='store_true', help='List completed tasks as well. Default is to only list backlog/in-progress')
            
            items_p_arg_group = items_p.add_mutually_exclusive_group()
            items_p_arg_group.add_argument('-l', '--list', action='store_true', help='List items.')
            
            item_p = subparsers.add_parser('item', help='Display Item Specifics or Edit an item')
            item_p.set_defaults(func=self._item_action, new=False)
            item_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to list or edit')
            item_p.add_argument('-s', '--status', type=str, help='The new status to set this item to', choices=ITEM_STATUSES.keys())
            item_p.add_argument('-z', '--size', type=str, help='The approximate size of the item', choices=ITEM_SCORES.keys())
            item_p.add_argument('-t', '--title', type=str, help='The new title to set for this item')
            item_p.add_argument('-u', '--user', type=int, help='The User ID to assign this item to')
            item_p.add_argument('-d', '--description', action='store_true', help='Starts an editor for you to insert a description')
            item_p.add_argument('-g', '--tags', type=str, help='comma delimited tags to attach to the item')
            item_p.add_argument('-p', '--parent', type=int, help='The parent story to add this to')
            item_p.add_argument('-r', '--remove', action='store_true', help='REMOVES THE ITEM')
            item_p.add_argument('-c', '--comment', action='store_true', help='Adds a new comment to the item')

            add_p = subparsers.add_parser('add', help='Add a new item to sprintly')
            add_p.set_defaults(func=self._item_action, new=True, itemID=None, comment=False)
            add_p.add_argument('type', metavar='type', type=str, help='The new item type to add', choices=ITEM_COLORS.keys())
            add_p.add_argument('title', metavar='title', type=str, help='The new title to set for this item')
            add_p.add_argument('-d', '--description', action='store_true', help='Starts an editor for you to insert a description')
            add_p.add_argument('-s', '--status', type=str, help='The new status to set this item to', choices=ITEM_STATUSES.keys())
            add_p.add_argument('-z', '--size', type=str, help='The approximate size of the item', choices=ITEM_SCORES.keys())
            add_p.add_argument('-u', '--user', type=int, help='The User ID to assign this item to')
            add_p.add_argument('-g', '--tags', type=str, help='comma delimited tags to attach to the item')
            add_p.add_argument('-p', '--parent', type=int, help='The parent story to add this to (non stories only)')
            add_p.add_argument('--who', type=str, help='Required for stories, who is requesting this')
            add_p.add_argument('--what', type=str, help='Required for stories, what is this story for')
            add_p.add_argument('--why', type=str, help='Required for stories, why is this story important')

            start_p = subparsers.add_parser('start', help='Start a task (equiv. to "sprintly item <item id> -s in-progress -u <your id>").')
            start_p.set_defaults(func=self._item_action, new=False,
                                                         remove=False,
                                                         description=False,
                                                         size=None,
                                                         title=None,
                                                         tags=None,
                                                         parent=None,
                                                         status='in-progress',
                                                         user=self._this_user())
            start_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to start.')
            start_p.add_argument('-c', '--comment', action='store_true', help='Adds a new comment to the item')

            stop_p = subparsers.add_parser('stop', help='Move a task to your backlog (equiv. to "sprintly item <item id> -s backlog -u <your id>").')
            stop_p.set_defaults(func=self._item_action, new=False,
                                                        remove=False,
                                                        description=False,
                                                        size=None,
                                                        title=None,
                                                        tags=None,
                                                        parent=None,
                                                        status='backlog',
                                                        user=self._this_user())
            stop_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to put in your backlog.')
            stop_p.add_argument('-c', '--comment', action='store_true', help='Adds a new comment to the item')

            complete_p = subparsers.add_parser('complete', help='Move a task to completed.')
            complete_p.set_defaults(func=self._item_action, new=False,
                                                        remove=False,
                                                        description=False,
                                                        size=None,
                                                        title=None,
                                                        tags=None,
                                                        parent=None,
                                                        status='completed',
                                                        user=self._this_user())
            complete_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to move to completed (equiv. to "sprintly item <item id> -s completed -u <your id>").')
            complete_p.add_argument('-c', '--comment', action='store_true', help='Adds a new comment to the item')

            self.parser = parser
            args = parser.parse_args()
            args.func(args)

        except Exception as e:
            die('Fatal Error: %s', e)

    def _initAndUpdateConfig(self, args):
        self.updateConfig()

    def _installAndInit(self, args):
        self._installOrUpdateAndInit(False)

    def _updateAndInit(self, args):
        self._installOrUpdateAndInit(True)

    def _installOrUpdateAndInit(self, update):
        try:
            self.install(update)
        except SprintlyException:
            type = 'install'
            if update:
                type = 'update'
            self.cprint('Unable to %s. Try running again with sudo.' % (type), attr=RED)
        return
        self.initialize()

    def _users_action(self, args):
        
        # default to listing users
        self.listSprintlyUsers(args.product)

    def _items_action(self, args=None):
        if args:
            #default is to list items
            self.listSprintlyItems(args.user, args.completed)
            return
        
        # default action, list this user's items:
        self.listSprintlyItems()

    def _item_action(self, args):
        pid = str(self._config['product']['id'])
        
        if args.itemID:
            itemID = str(args.itemID)
        else:
            itemID = None

        if itemID and args.remove:
            if not itemID:
                self.cprint("Can't delete something that hasn't been created")
                return
            if self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '.json', delete=True):
                self.cprint('Successfully Removed Item ' + itemID)
            else:
                self.cprint('Failed to remove item ' + itemID)
            return

        updates = []
        if args.status:
            if args.status not in ITEM_STATUSES.keys():
                self.parser.print_help()
                return
            updates.append(('status', args.status))

        if args.size:
            if args.size not in ITEM_SCORES.keys():
                self.parser.print_help()
                return
            updates.append(('score', args.size))

        if args.title:
            updates.append(('title', args.title))

        if args.user:
            updates.append(('assigned_to', args.user))

        if args.description:
            description = messageFromEditor('Description')
            if not description:
                self.cprint('No Description Entered')
            else:
                updates.append(('description', description))

        if args.tags:
            updates.append(('tags', args.tags))

        if args.parent:
            updates.append(('parent', args.parent))

        if not itemID:
            if args.type not in ('defect', 'test', 'task', 'story'):
                self.cprint('Unsupported type for a new item')
                self.parser.print_help()
                return
            updates.append(('type', args.type))

            if args.type == 'story':
                if not all([args.who, args.what, args.why]):
                    self.cprint('Missing Required Parameters For Story Type')
                    self.parser.print_help()
                    return
                updates.append(('who', args.who))
                updates.append(('what', args.what))
                updates.append(('why', args.why))

            resp = self.sprintlyAPICall('products/' + pid + '/items.json', updates)
            if not resp:
                self.cprint("Couldn't create the new item, check internet connection")
                return 
            
            itemID = str(resp['number'])

        else:
            self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '.json', updates)

        if args.comment:
            comment = messageFromEditor('Comment')
            if not comment:
                self.cprint('No Comment entered')
                return
            if self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '/comments.json', [('body', comment)]):
                self.cprint('Successfully Commented on Item ' + itemID)
            else:
                self.cprint('Failed to comment, check internet connection')
            return

        item = self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '.json')
        #print item

        color = ITEM_COLORS.get(item['type'])
        
        printItem = '''${%s}#%d${DEFAULT} (%s):${BOLD} %s${RESET}\n\tAssigned To: ${BOLD}%s${RESET}\n\tScore: ${BOLD}%s${RESET}\n'''

        if not item['assigned_to']:
            assigned_to = 'Unassigned'
        else:
            assigned_to = item['assigned_to']['first_name'] + ' ' + item['assigned_to']['last_name']

        self.cprint(printItem % (
            color, item['number'], ITEM_STATUSES[item['status']], item['title'],
            assigned_to, ITEM_SCORES[item['score']]
        ))
        if len(item['description']):
            self.cprint('${UNDERLINE}${MAGENTA}Description:${RESET}${DEFAULT}')
            self.cprint('\t' + item['description'] + '\n')
        
        if item['type'] == 'story':
            children = self.sprintlyAPICall('/products/' + pid + '/items/' + itemID + '/children.json')
            if len (children) > 0:
                self.cprint('${UNDERLINE}${MAGENTA}Children:${RESET}${DEFAULT}')
                products = [{'id': pid, 'items': children, 'name': 'Vadio'}]
                self.printItems(products, False)

        comments = self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '/comments.json')
        if len(comments) > 0:
            self.cprint('${UNDERLINE}${MAGENTA}Comments:${RESET}${DEFAULT}')
            for comment in comments:
                name = comment['created_by']['first_name'] + ' ' + comment['created_by']['last_name']
                self.cprint('${DIM}%s${RESET}: %s' % (name, comment['body']))


    def install(self, update):
        """
        Install this tool at SPRINTLY_PATH. If another file already
        exists with the same name, user will be prompted to replace the file.
        """

        print 'Downloading latest version of sprintly from GitHub...'

        # get the file
        try:
            response = urllib2.urlopen(SPRINTLY_SOURCE_URL)
            sprintly_file_contents = response.read()
        except Exception:
            raise SprintlyException('Unable to obtain sprintly from %s' % SPRINTLY_SOURCE_URL)

        # verify nothing exists at the target path
        target = SPRINTLY_PATH
        if os.name == 'nt': target += '.py'
        if os.path.isfile(target):
            overwrite = raw_input(self.render('${BRIGHT_YELLOW}A file already exists at %s.${RESET} Overwrite file? ' % target, trim=False))
            while overwrite != 'y' and overwrite != 'n':
                overwrite = raw_input('Please enter y/n: ')

            if overwrite == 'n':
                self.cprint('Unable to install. Please install manually.', attr=RED)
                return

            # remove existing file
            print 'Deleting %s...' % target
            try:
                os.unlink(target)
            except Exception:
                raise SprintlyException('Unable to remove %s' % target)

        # copy file to target
        try:
            if not os.path.isdir(SPRINTLY_DIR):
                os.makedirs(SPRINTLY_DIR)
            target_file = open(target, 'w')
            target_file.write(sprintly_file_contents)
            target_file.close()
        except Exception:
            raise SprintlyException('Unable to save file to %s' % target)

        # ensure it is executable
        try:
            subprocess.call(['chmod', '+x', target])
        except Exception:
            raise SprintlyException('Unable to make %s executable.' % target)

        # done!
        self.cprint('Successfully installed sprintly to %s' % target, attr=GREEN)
        
        # if this is not an update, install
        if not update:
            print ''
            self.cprint('That\'s all! Type \'sprintly\' and hit enter to get started.', attr=BRIGHT_MAGENTA)
            print ''

    def initialize(self):
        """
        Ultimate goal is to get the user and key from the config file.
        If the config file cannot be found, a config file will be
        created via prompts displayed to the user. A cache file will
        also be created during this step.
        """

        # get the users home directory
        home = os.path.expanduser('~')
        if home == '~':
            raise SprintlyException('Unable to expand home directory.')

        # set the sprintly directory path (create if it doesn't exist)
        self._sprintlyDirectoryPath = os.path.join(home, '.sprintly')
        if not os.path.isdir(self._sprintlyDirectoryPath):
            os.mkdir(self._sprintlyDirectoryPath, 0700)
            if not os.path.isdir(self._sprintlyDirectoryPath):
                raise SprintlyException('Unable to create folder at %s' % self._sprintlyDirectoryPath)

        # set the sprintly config path (create if it doesn't exist)
        self._sprintlyConfigPath = os.path.join(self._sprintlyDirectoryPath, 'sprintly.config')
        if not os.path.isfile(self._sprintlyConfigPath):
            self.createSprintlyConfig()
        
        # load config values
        self.loadFromConfig()

    def createSprintlyConfig(self, update=False):
        """
        Create the Sprint.ly config. Prompt user for all necessary values.

        When 'update' is set to True and an existing value is present for
        a given configuration item, allow user to keep old value.

        Note: if update is True, this must be called after initialize. Failure
        to do so wil result in a new config being created, as the values in
        self._config will not yet be set.
        """

        if not update:
            print 'Creating config...'
        else:
            print 'Updating config... Press enter to accept default value shown in brackets.'

        # set version
        self._config['version'] = CONFIG_VERSION

        # used to simplify prompting user with optional default
        def getConfigItem(message, default=None):
            if default:
                item = raw_input(self.render('%s [${YELLOW}%s${RESET}]: ' % (message, default), trim=False)) or default
            else:
                item = raw_input('%s: ' % message)
            return item

        # prompt for user
        name = 'user'
        message = 'Enter Sprint.ly username (email)'
        if update and name in self._config:
            self._config[name] = getConfigItem(message, self._config[name])
        else:
            self._config[name] = getConfigItem(message)

        # prompt for key
        name = 'key'
        message = 'Enter Sprint.ly API Key'
        if update and name in self._config:
            self._config[name] = getConfigItem(message, self._config[name])
        else:
            self._config[name] = getConfigItem(message)

        # try and use API with these values to determine validity
        response = self.sprintlyAPICall('user/whoami.json')
        if not response or 'code' in response:
            raise SprintlyException('Invalid credentials. Unable to authenticate with Sprint.ly.')
        if response['email'] != self._config['user']:
            raise SprintlyException('Invalid credentials. Please ensure you are using your own API Key.')

        # add user id to config
        self._config['id'] = response['id']

        # get a list of products and prompt user for default product if more than 1
        products = self.sprintlyAPICall('products.json')
        if not products:
            raise SprintlyException('Unable to get product list.')
        productMap = {}

        for product in products:
            productId = str(product['id'])
            productMap[productId] = product

        productCount = len(productMap)

        if productCount == 0:
            raise SprintlyException('It appears that you have no products associated with your Sprint.ly account. Please add at least one and then try again.')
        elif productCount == 1:
            self._config['product'] = productMap.values()[0]
        else:
            # prompt user for a product until they enter one found in the map
            productList = ', '.join(['%d - %s' % (p['id'], p['name']) for p in productMap.values()])
            defaultProductId = '0'
            while defaultProductId not in productMap.keys():
                message = 'Enter default Sprint.ly product id (%s)' % productList
                if update and 'product' in self._config:
                    defaultProductId = getConfigItem(message, str(self._config['product']['id']))
                else:
                    defaultProductId = getConfigItem(message)
            self._config['product'] = productMap[defaultProductId]

        # write config file if all is good
        serialized_config = json.dumps(self._config)

        try:
            config_file = open(self._sprintlyConfigPath, 'w')
            config_file.write(serialized_config)
            config_file.close()
            if not update:
                self.cprint('Configuration successfully created.', attr=GREEN)
            else:
                self.cprint('Configuration successfully updated.', attr=GREEN)
        except:
            raise SprintlyException('Unable to write configuration to disk at %s' % self._sprintlyConfigPath)

    def loadFromConfig(self):
        """
        Load user and key from the config file. Validate here that the version
        of this config is readable by this version of the tool.
        """

        try:
            config_file = open(self._sprintlyConfigPath, 'r')
            serialized_config = config_file.readline()
            config_file.close()
            self._config = json.loads(serialized_config)
        except:
            raise SprintlyException('Unable to read credentials from disk at %s' % self._sprintlyConfigPath)

        # validate version
        if 'version' not in self._config or self._config['version'] != CONFIG_VERSION:
            self.cprint('Your configuration needs to be updated. You will now be prompted to update it.', attr=YELLOW)
            self.updateConfig()

    def updateConfig(self):
        """
        Prompt user to update configuration settings.
        Defaults will be original config values if present.
        """
        self.createSprintlyConfig(True)

    def listSprintlyUsers(self, byProducts=False):
        """
        Lists all Sprint.ly users by product.
        """
        data = self.getSprintlyUsers(byProducts)
        if not byProducts:
            self.printUserArray(data)
            return
        self.printUsersByProducts(data)

    def printUsersByProducts(self, products):
        """
        List users by the product they work on.
        """
        for product in products:
            users = product['users']
            productId = str(product['id'])
            productName = product['name']
            printProduct = '${DEFAULT}Product: ${BOLD}${BRIGHT_BLUE}' + productName + '${NORMAL}${GREY} (https://sprint.ly/product/' + productId + '/)'
            self.cprint(printProduct)
            
            for user in users:
                printUser = '${NORMAL}  ' + str(user['id']) + ': ${BOLD}${LIGHT_BLUE}' + user['first_name'] + ' ' + user['last_name'] + ' ${NORMAL}${GREY}(' + user['email'] + ')'
                self.cprint(printUser)
        self.cprint('')

    def printUserArray(self, users):
        """
        List all users from all products.
        """
        for user_id in users:
            user = users[user_id]
            printUser = '${NORMAL}' + str(user['id']) + ': ${BOLD}${LIGHT_BLUE}' + user['first_name'] + ' ' + user['last_name'] + ' ${NORMAL}${GREY}(' + user['email'] + ')'
            self.cprint(printUser)
        self.cprint('')

    def listSprintlyItems(self, userId = None, listCompletedItems=False):
        """
        Lists all items for the current user from the Sprint.ly API.
        """
        data = self.getSprintlyItems(userId, listCompletedItems, 1000)
        self.printItems(data)

    def printItems(self, products, shouldPrintHeader=True):
        """
        Print a list of Sprint.ly items.
        """
        
        statusTree = {
            'someday': {},
            'backlog': {},
            'in-progress': {},
            'completed': {},
            'accepted': {},
        }

        # An order that puts least viewed at the top and most viewed close
        # to the bottom close to the command line
        order = ['accepted', 'someday', 'completed', 'backlog', 'in-progress']

        for product in products:
            prevIds = []
            for item in product['items']:
                # If the item is already in the list or is assigned to someone
                # else, it could mean this entry contains children with a
                # different status:
                yourTask = 'assigned_to' in item and item['assigned_to']['id'] == self._this_user()
                productNotInTree = not product['id'] in statusTree[item['status']]
                itemInTree = item['number'] in prevIds
                itemNotInTree = not itemInTree
                if itemNotInTree and yourTask:
                    # Straight forward, just add to status of parent
                    if productNotInTree:
                        statusTree[item['status']][product['id']] = [item]
                    else:
                        statusTree[item['status']][product['id']].append(item)
                    prevIds.append(item['number'])
                else:
                    # Either not your task or already in tree. If not your task,
                    # then the relavent status is the one of the subtasks that
                    # /are/ assigned to you. If this task is already in the tree,
                    # then the relavent status is that of a child.
                    parentItem = 'children' in item
                    diffChildStatus = parentItem and item['children'][0]['status'] != item['status']
                    if diffChildStatus:
                        children = item['children']
                        first_child = children[0]
                        if not product['id'] in statusTree[first_child['status']]:
                            statusTree[first_child['status']][product['id']] = []
                        statusTree[first_child['status']][product['id']].append(item)
                        prevIds.append(item['number'])
                    else:
                        if itemNotInTree:
                            statusTree[item['status']][product['id']] = [item]
                        else:
                            statusTree[item['status']][product['id']].append(item)
                        prevIds.append(item['number'])

        for key in order:
            status = statusTree[key]
            if not len(status):
                continue

            self.cprint(ITEM_STATUSES[key], attr=[BRIGHT_MAGENTA, UNDERLINE])

            for product_id in status:
                items = status[product_id]
                name = items[0]['product']['name']
                productId = str(items[0]['product']['id'])
                
                if shouldPrintHeader:
                    printProduct = '${DEFAULT}Product: ${BOLD}${BRIGHT_BLUE}' + name + '${NORMAL}${GREY} (https://sprint.ly/product/' + productId + '/)'
                    self.cprint(printProduct)

                title_color = 'DEFAULT'
                for item in items:
                    if not item['assigned_to']:
                        assigned_to = '(Unassigned)'
                    else:
                        assigned_to = '(' + item['assigned_to']['first_name'] + ' ' + item['assigned_to']['last_name'] + ')'

                    attr = None
                    if item['status'] != key:
                        attr = DIM
                    color = ITEM_COLORS.get(item['type'])

                    printItem = '${%s}%-6s${DEFAULT}     %18s:  ${%s}%s' % (
                        color, '#' + str(item['number']), assigned_to, title_color, item['title']
                    )
                    self.cprint(printItem, attr=attr)

                    if 'children' in item:
                        for child in item['children']:
                            attr = None
                            childColor = ITEM_COLORS.get(child['type'])
                            title = child['title']
                            if child['status'] == 'in-progress':
                                title = u'${GREEN}⧁ ${%s}%s' % (title_color, title)

                            if not child['assigned_to']:
                                assigned_to = 'Unassigned'
                            else:
                                assigned_to = '(' + child['assigned_to']['first_name'] + ' ' + child['assigned_to']['last_name'] + ')'

                            printChild = u'${%s}   %-6s${DEFAULT}  %18s:  ${%s}%s' % (
                                childColor, '#' + str(child['number']), assigned_to, title_color, title
                            )
                            self.cprint(printChild, attr=attr)

            self.cprint('')

    def getSprintlyItems(self, userId=None, listCompletedItems=False, limit=100):
        """
        Get all Sprint.ly items. By default gets them for local user, but can
        also retrieve for other users when given a user ID.
        """
        
        if not userId:
            userId = self._config['id']
        
        l_products = self._getSprintlyItemsCore(userId, limit=limit)
        if listCompletedItems:
            t_data = self._getSprintlyItemsCore(userId, status='completed', limit=limit, assoc=True)
            for product in l_products:
                if str(product['id']) in t_data:
                    product['items'] = product['items'] + t_data[str(product['id'])]['items']
        return l_products

    def _getSprintlyItemsCore(self, userId=None, status=None, limit=100, assoc=False):
        """
        Get Sprint.ly items. By default, just in-progress and backlog items are
        listed. Specify a status to limit to that status. pass assoc=True to 
        get an associative array back linking product IDs to products, rather
        than the default array of products.
        """
        
        if status != None:
            status = '&status=' + status
        else:
            status = ''
        
        data = None
        if assoc:
            data = {}
        else:
            data = []
        products = []
        
        try:
            # use product from config file
            product = {'name': self._config['product']['name'],
                       'id': self._config['product']['id']};
            products.append(product)
            
            # get products from the API
            # products = self.sprintlyAPICall('products.json')
            # if not products:
            #   raise SprintlyException('Unable to get product list.')
            
            # iterate over products
            for product in products:
                
                productName = product['name']
                productId = str(product['id'])
                
                items = []
                offset = 0
                while True:
                    itemsPartial = self.sprintlyAPICall('products/' + productId + '/items.json?assigned_to=' + str(userId) + status + '&children=1&limit=' + str(limit) + '&offset=' + str(offset))

                    # if we get nothing, an empty list, an error, quit
                    if not itemsPartial or len(itemsPartial) == 0 or 'code' in items:
                        break
                    # otherwise, add on these items and increase the offset
                    else:
                        items = items + itemsPartial
                        offset = offset + limit

                    # if we got less than a full response, no need to check again
                    if len(itemsPartial) < limit:
                        break

                # if anything went wrong, print an error message
                if 'code' in items:
                    # include message if applicable
                    message = ''
                    if 'message' in items:
                        message = ': %s' % items['message']
                    productNameWithUrl = '\'' + productName + '\' (https://sprint.ly/product/' + productId + '/)'
                    print 'Warning: unable to get items for %s%s' % (productNameWithUrl, message)
                    continue
                # if there are no items, display message
                elif len(items) == 0:
                    productNameWithUrl = '\'' + productName + '\' (https://sprint.ly/product/' + productId + '/)'
                    print 'No assigned items for %s' % (productNameWithUrl)
                
                # a 'parent' is any item without a parent key
                # a 'child' is any item with a parent key
                # sort so that all parents appear first and all children appear after ordered by their number
                items.sort(key=lambda item: item['number'] if 'parent' in item else sys.maxint, reverse=True)

                # turn flat list into tree
                itemsTree = []
                parentMapping = {} # allow parents to be looked up by number

                for item in items:
                    number = str(item['number'])

                    # if item is not a child
                    if 'parent' not in item:
                        itemsTree.append(item)
                        parentMapping[number] = item

                    # if item is a child...
                    else:
                        parent = item['parent']  # get reference to parent
                        del item['parent']  # remove parent from child
                        parentNumber = str(parent['number'])

                        # if we have the parent, nest under parent
                        if parentNumber in parentMapping:

                            # we sorted items above to ensure all parents will be in map before any child is encountered
                            parent = parentMapping[parentNumber]
                            if 'children' not in parent:
                                parent['children'] = []
                            parent['children'].append(item)

                        # if we don't have the parent, add placeholder parent to preserve tree structure
                        else:
                            parent['children'] = [item]
                            parentMapping[parentNumber] = parent
                            itemsTree.append(parent)

                # sort items by (status, then first child, if it exists, else number)
                itemsTree.sort(key=lambda item: item['children'][0]['number'] if 'children' in item else item['number'], reverse=True)
                product['items'] = itemsTree
                
                if assoc:
                    data[productId] = product
                else:
                    data.append(product)
            
            return data
        except Exception as ex:
            print '\033[91m'
            print 'Unable to get sprintly data. (exception: ' + str(ex) + ')'
            print '\033[0m'
            return None

    def getSprintlyUsers(self, byProducts=False):
        """
        Get all Sprint.ly users.
        
        If byProducts == True, returns an array of
        products: [{name:string, id:number, users:[]}, ...]
        
        If byProducts == False, returns an assoc array of
        users: {<user_id>: {admin: bool, first_name: string, last_name: string,
                 id: number, email: string}, ...}
        """
        try:
            products = []
            users = {}
            
            # use product from config file
            products.append(self._config['product'])
            
            # get products from the API
            # products = self.sprintlyAPICall('products.json')
            # if not products:
            #   raise SprintlyException('Unable to get product list.')
            
            # iterate over products
            for product in products:
                productName = product['name']
                productId = str(product['id'])
                product['users'] = self.sprintlyAPICall('products/' + productId + '/people.json')
                
                # iterate over users adding to global user array
                for user in product['users']:
                    users[user['id']] = user
            
            if byProducts:
                return products
            return users
            
        except Exception as ex:
            print '\033[91m'
            print 'Unable to get sprintly data. (exception: ' + str(ex) + ')'
            print '\033[0m'
            return None

    def sprintlyAPICall(self, url, data=None, delete=False):
        """
        Wraps up a call to the Sprint.ly api. Returns a map representing
        the JSON response or false if the call could not be completed.
        @param (list|tuple of 2-tuples) data - Data to be passed as post to server
        @param (bool) delete - Whether to send as a DELETE method
        """

        url = 'https://sprint.ly/api/%s' % url

        try:
            userData = 'Basic ' + (self._config['user'] + ':' + self._config['key']).encode('base64').replace("\n",'')
            opener = urllib2.build_opener(urllib2.HTTPHandler)
            
            if data:
                data = urllib.urlencode(data)
            
            req = urllib2.Request(url, data=data)
            req.add_header('Accept', 'application/json')
            req.add_header('Authorization', userData)

            if delete:
                req.get_method = lambda: 'DELETE'

            res = opener.open(req)
            
            response = res.read()
            return json.loads(response)
        except urllib2.HTTPError, error:
            response = error.read()
            return json.loads(response)
        except Exception:
            return False
    
    def cprint(self, str, attr=None, trim=True):
        self._term.write(self.render(str, attr, trim) + '\r\n')

    def render(self, str, attr=None, trim=True):
        if self._has_color:
            if attr:
                if isinstance(attr, list):
                    attr = ''.join(attr)
            else:
                attr = ''

            seq = re.sub(r'\$\$|\${\w+}', self._render_sub, str)
            if trim:
                seq = self._trim(seq)

            return attr + seq + RESET
        else:
            seq = re.sub(r'\$\$|\${\w+}', '', str)
            if trim and len(seq) > self._cols:
                return seq[0:self._cols - 1] + u'\u2026'
            return seq

    def _render_sub(self, match):
        s = match.group()
        if s == '$$':
            return s
        else:
            return ATTRS.get(s[2:-1], '')

    def _trim(self, raw):
        # TODO: >>> This could probably be much simpler if I was smarter
        seq = ''
        str_len = 0
        i = 0
        matchiter = re.finditer(r'(\x1b.*?m)', raw.strip())
        for match in matchiter:
            chunk = raw[i:match.start()]
            i = match.end()
            if str_len + len(chunk) > self._cols:
                chunk = chunk[0:self._cols - str_len - 1] + u'\u2026'
            str_len = str_len + len(chunk)
            seq = seq + chunk + match.group()

            if (str_len >= self._cols):
                break

        if str_len < self._cols:
            chunk = raw[i:]
            if str_len + len(chunk) > self._cols:
                chunk = chunk[0:self._cols - str_len - 1] + u'\u2026'
            seq = seq + chunk

        return seq

    def elipsify(self, seq):
        return seq[0:-1].strip(string.punctuation) + u'\u2026'

    def _this_user(self):
        if not 'id' in self._config:
            return None
        return self._config['id']


class SprintlyException(Exception):
    """
    Exception used to pass known exceptions throughout
    the sprintly tool.
    """
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


def die(message=None, *args):
    """
    Prints the message, if present, and then exits.
    """

    if message:
        logger.error(message, *args, exc_info=True)
    print 'Program exiting.'
    sys.exit(1)

if __name__ == '__main__':
    sprintlyTool = SprintlyTool()
    sprintlyTool.run()
