#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import sys, os, locale, urllib, urllib2, json, subprocess, re, string, logging, os, tempfile, traceback
from curses import setupterm, tigetstr, tigetnum, tparm
from time import time
from argparse import ArgumentParser
from subprocess import call
if os.name == 'nt': import ctypes, struct

try:
    import tre
    FUZ0 = tre.Fuzzyness(maxerr = 0)
    FUZ1 = tre.Fuzzyness(maxerr = 1)
    FUZ2 = tre.Fuzzyness(maxerr = 2)
except ImportError:
    FUZ = None
    print 'Fuzzy regex not available, search will not work'

# force utf-8 encoding
reload(sys)
sys.setdefaultencoding('utf-8')

if os.name == 'nt': import uniconsole

logging.basicConfig()
logger = logging.getLogger(__name__)

# constants
CONFIG_VERSION = '2.1'
SPRINTLY_NAME = 'sprintly'
SPRINTLY_DIR = '/usr/local/bin/' if os.name != 'nt' else os.environ.get("PYTHONHOME") + '/Scripts/'
SPRINTLY_SOURCE_URL = 'https://raw.github.com/bumboarder6/Sprintly-GitHub/master/sprintly'

# non-editable constants
SPRINTLY_PATH = SPRINTLY_DIR + SPRINTLY_NAME

# tty colors
DEFAULT = '\x1b[39m'
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, LIGHT_GREY = [('\x1b[%dm' % (30 + i)) for i in range(8)]
GREY, BRIGHT_RED, BRIGHT_GREEN, BRIGHT_YELLOW, BRIGHT_BLUE, BRIGHT_MAGENTA, BRIGHT_CYAN, WHITE = [('\x1b[%dm' % (90 + i)) for i in range(8)]
RESET, NORMAL, BOLD, DIM, UNDERLINE, INVERT, HIDDEN = [('\x1b[%dm' % i) for i in (0, 22, 1, 2, 4, 7, 8)]
ATTRS = {
    'DEFAULT': DEFAULT,
    'BLACK': BLACK, 'RED': RED, 'GREEN': GREEN, 'YELLOW': YELLOW, 'BLUE': BLUE, 'MAGENTA': MAGENTA, 'CYAN': CYAN, 'LIGHT_GREY': LIGHT_GREY,
    'GREY': GREY, 'BRIGHT_RED': BRIGHT_RED, 'BRIGHT_GREEN': BRIGHT_GREEN, 'BRIGHT_YELLOW': BRIGHT_YELLOW, 'BRIGHT_BLUE': BRIGHT_BLUE, 'BRIGHT_MAGENTA': BRIGHT_MAGENTA, 'BRIGHT_CYAN': BRIGHT_CYAN, 'WHITE': WHITE,
    'RESET': RESET, 'NORMAL': NORMAL, 'BOLD': BOLD, 'DIM': DIM, 'UNDERLINE': UNDERLINE, 'INVERT': INVERT, 'HIDDEN': HIDDEN
}

ITEM_COLORS = {
    'story': 'GREEN',
    'task': 'GREY',
    'defect': 'RED',
    'test': 'CYAN'
}

ITEM_STATUSES = {
    'someday': 'Someday',
    'backlog': "Backlog",
    'in-progress': "In Progress",
    'completed': "Completed",
    'accepted': "Accepted",
}

ITEM_SCORES = {
    '~': 'No Score',
    'S': 'Small Matter',
    'M': 'Eh Kinda Hard',
    'L': 'Breakin a sweat',
    'XL': 'WTF'
}

EDITOR = os.environ.get('EDITOR', 'emacs')


INIT_MSG = '# Please enter your %s below, any commented lines will be removed'

def messageFromEditor(usage, replace=False):
    """ Spawns an editor with the init message in it then returns the contents
        after it is finished and saved, returns None if there was an empty file """
    tmp = tempfile.NamedTemporaryFile(suffix=".tmp", delete=False)
    if not replace:
        tmp.write(INIT_MSG % (usage,))
    else:
        tmp.write(usage)
    tmp.flush()
    name = tmp.name
    tmp.close()
    call([EDITOR, name])
    tmp = open(name, 'r')
    data = tmp.read()
    tmp.close()
    os.remove(name)
    return re.sub('^\s*#.*?$', '', data, flags=re.M | re.I).strip()


def getHighlightedStr(data, regex):
    """ Highlights the matches of the pattern in the string by
        coloring them bright green then it returns the string,
        assumes regex is a (pattern, and fuz object)"""
    pat = regex[0]
    fuz = regex[1]
    new_data = ''
    match = pat.search(data, fuz)
    while match:
        group = match.groups()[0]
        new_data += data[:group[0]] + '${GREEN}' + data[group[0]:group[1]] + '${DEFAULT}'
        data = data[group[1]:]
        match = pat.search(data, fuz)

    return new_data + data
    

class SprintlyTool:
    """
    A command line tool for displaying your stories, tasks, tests, and defects
    from Sprint.ly.
    """

    def __init__(self, term_stream=sys.stdout):
        """
        Initialize instance variables.
        """
        
        # Set up terminal
        if os.name != 'nt': locale.setlocale(locale.LC_ALL, '')
        self._encoding = locale.getpreferredencoding()

        self._term = term_stream or sys.__stdout__
        self._is_tty = False
        self._has_color = False
        self._cols = 80

        if hasattr(term_stream, "isatty") and term_stream.isatty():
            try:
                if os.name != 'nt': 
                    setupterm()
                    self._has_color = (tigetnum('colors') > 2)
                    self._cols = tigetnum('cols')
                else:
                    self._has_color = True
                    self._cols = _get_terminal_size_windows()[0] - 1
                
                self._is_tty = True
            except:
                pass
        else:
            try:
                (_, columns) = os.popen('stty size', 'r').read().split()
                self._cols = int(columns)
            except:
                pass
        
        self._config = {}
        self._sprintlyDirectoryPath = None
        self._sprintlyConfigPath = None
        self.parser = None

    def run(self, scr=None):
        """
        Application flow.
        """
        
        # self.cprint('${BLACK} Black ${RED} RED ${GREEN} GREEN ${YELLOW} YELLOW ${BLUE} BLUE ${MAGENTA} MAGENTA ${CYAN} CYAN ${LIGHT_GREY} LIGHT_GREY ${GREY} GREY ${BRIGHT_RED} BRIGHT_RED ${BRIGHT_GREEN} BRIGHT_GREEN ${BRIGHT_YELLOW} BRIGHT_YELLOW ${BRIGHT_BLUE} BRIGHT_BLUE ${BRIGHT_MAGENTA} BRIGHT_MAGENTA ${BRIGHT_CYAN} BRIGHT_CYAN ${WHITE} WHITE')
        
        try:
            self.initialize()
            
            if len(sys.argv) == 1:
                self._items_action()
                return

            match = re.match('^-(\d+)$', sys.argv[1])
            if len(sys.argv) > 1 and match:
                sys.argv.insert(1, 'item')
                sys.argv[2] = match.group(1)
                
            description = 'By default, your Sprint.ly items will be shown.'
            
            parser = ArgumentParser(description=description)
            subparsers = parser.add_subparsers(dest='action_name')
            install_p = subparsers.add_parser('install', help='install this tool.')
            install_p.set_defaults(func=self._installAndInit)

            update_p = subparsers.add_parser('update', help='update this tool.')
            update_p.set_defaults(func=self._updateAndInit)

            update_config_p = subparsers.add_parser('update-config', help='edit configuration.')
            update_config_p.set_defaults(func=self._initAndUpdateConfig)

            users_p = subparsers.add_parser('users', help='Get/set user information. Lists users by default.')
            users_p.set_defaults(func=self._users_action)
            users_p.add_argument('-p', '--product', action='store_true', help='List users by the product they work on.')

            users_p_arg_group = users_p.add_mutually_exclusive_group()
            users_p_arg_group.add_argument('-l', '--list', action='store_true', help='List users.')

            items_p = subparsers.add_parser('items', help='Lists your items by default')
            items_p.set_defaults(func=self._items_action)
            items_p.add_argument('-c', '--completed', action='store_true', help='List completed tasks as well. Default is to only list backlog/in-progress')
            items_p.add_argument('-s', '--someday', action='store_true', help='List someday (or triage) tasks as well. Default is to only list backlog/in-progress')
            items_p.add_argument('-b', '--omit-backlog', dest='omit_backlog', action='store_true', help='Do not show backlog items.')
            items_p.add_argument('-i', '--omit-in-progress', dest='omit_in_progress', action='store_true', help='Do not show in-progress items.')

            items_p_arg_group = items_p.add_mutually_exclusive_group()
            items_p_arg_group.add_argument('-u', '--user', default=None, help='Specify a user. Defaults to you. Matches against email.')
            items_p_arg_group.add_argument('-z', '--unassigned', action='store_true', help='Specify that only unassigned items should be listed.')
            items_p_arg_group.add_argument('-y', '--anyone', action='store_true', help='Specify that items assigned to anyone should be listed.')

            search_p = subparsers.add_parser('search', help='Search for matching items')
            search_p.set_defaults(func=self._search_action)
            search_p.add_argument('query', metavar='query', type=str, help='The regular expression to search sprintly items for')
            search_p.add_argument('-c', '--completed', action='store_true', help='Search completed tasks as well. Default is to only search backlog/in-progress')
            search_p.add_argument('-s', '--someday', action='store_true', help='Search someday (or triage) tasks as well. Default is to only search backlog/in-progress')
            search_p.add_argument('-b', '--omit-backlog', dest='omit_backlog', action='store_true', help='Do not search backlog items.')
            search_p.add_argument('-a', '--search-all', dest='searchAll', action='store_true', help='Shortcut for -c -s')
            search_p.add_argument('-m', '--search-comments', dest='searchComments', action='store_true', help='Optionally comment fields')
            
            item_p = subparsers.add_parser('item', help='Display Item Specifics or Edit an item')
            item_p.set_defaults(func=self._item_action, new=False)
            item_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to list or edit')
            item_p.add_argument('-s', '--status', type=str, help='The new status to set this item to', choices=ITEM_STATUSES.keys())
            item_p.add_argument('-z', '--size', type=str, help='The approximate size of the item', choices=ITEM_SCORES.keys())
            item_p.add_argument('-t', '--title', type=str, help='The new title to set for this item')
            item_p.add_argument('-u', '--user', type=str, help='The user to assign this item to (email matched)')
            item_p.add_argument('-d', '--description', nargs='?', type=str, default=False, const=True, help='Starts an editor for you to insert a description')
            item_p.add_argument('-g', '--tags', type=str, help='comma delimited tags to attach to the item')
            item_p.add_argument('-p', '--parent', type=int, help='The parent story to add this to')
            item_p.add_argument('-r', '--remove', action='store_true', help='REMOVES THE ITEM')
            item_p.add_argument('-c', '--comment', nargs='?', type=str, default=False, const=True, help='Adds a new comment to the item')

            add_p = subparsers.add_parser('add', help='Add a new item to sprintly')
            add_p.set_defaults(func=self._item_action, new=True, itemID=None, comment=False)
            add_p.add_argument('type', metavar='type', type=str, help='The new item type to add', choices=ITEM_COLORS.keys())
            add_p.add_argument('title', metavar='title', type=str, help='The new title to set for this item (for stories, this is the "what")')
            add_p.add_argument('-d', '--description', nargs='?', type=str, default=False, const=True, help='Starts an editor for you to insert a description')
            add_p.add_argument('-s', '--status', type=str, help='The new status to set this item to', choices=ITEM_STATUSES.keys())
            add_p.add_argument('-z', '--size', type=str, help='The approximate size of the item', choices=ITEM_SCORES.keys())
            add_p.add_argument('-u', '--user', type=str, help='The user to assign this item to (email matched)')
            add_p.add_argument('-g', '--tags', type=str, help='comma delimited tags to attach to the item')
            add_p.add_argument('-p', '--parent', type=int, help='The parent story to add this to (non stories only)')
            add_p.add_argument('--who', type=str, help='Required for stories, who is requesting this')
            add_p.add_argument('--why', type=str, help='Required for stories, why is this story important')

            start_p = subparsers.add_parser('start', help='Start a task (equiv. to "sprintly item <item id> -s in-progress -u <your id>").')
            start_p.set_defaults(func=self._item_action, new=False, remove=False, description=False, size=None, title=None, tags=None,
                                 parent=None, status='in-progress', user=self._this_user())
            start_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to start.')
            start_p.add_argument('-c', '--comment', nargs='?', type=str, default=False, const=True, help='Adds a new comment to the item')

            stop_p = subparsers.add_parser('stop', help='Move a task to your backlog (equiv. to "sprintly item <item id> -s backlog -u <your id>").')
            stop_p.set_defaults(func=self._item_action, new=False, remove=False, description=False, size=None, title=None, tags=None,
                                parent=None, status='backlog', user=self._this_user())
            
            stop_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to put in your backlog.')
            stop_p.add_argument('-c', '--comment', action='store_true', help='Adds a new comment to the item')

            complete_p = subparsers.add_parser('complete', help='Move a task to completed.')
            complete_p.set_defaults(func=self._item_action, new=False, remove=False, description=False, size=None, title=None, tags=None,
                                    parent=None, status='completed', user=self._this_user())
            
            complete_p.add_argument('itemID', metavar='ID', type=int, help='The ID of the item to move to completed (equiv. to "sprintly item <item id> -s completed -u <your id>").')
            complete_p.add_argument('-c', '--comment', nargs='?', type=str, default=False, const=True, help='Adds a new comment to the item')

            self.parser = parser
            args = parser.parse_args()
            args.func(args)

        except Exception as e:
            die('Fatal Error: %s', e)

    def _initAndUpdateConfig(self, args):
        self.updateConfig()

    def _installAndInit(self, args):
        self._installOrUpdateAndInit(False)

    def _updateAndInit(self, args):
        self._installOrUpdateAndInit(True)

    def _installOrUpdateAndInit(self, update):
        try:
            self.install(update)
        except SprintlyException:
            type = 'install'
            if update:
                type = 'update'
            self.cprint('Unable to %s. Try running again with sudo.' % (type), attr=RED)
        return
        self.initialize()

    def _users_action(self, args):
        
        # default to listing users
        self.listSprintlyUsers(args.product)

    def _items_action(self, args=None):
        if args:
            if args.unassigned:
                args.user = None
            elif args.user is None:
                args.user = self._this_user()
            self.listSprintlyItems(args.user, not args.omit_backlog,
                                   not args.omit_in_progress, args.completed,
                                   args.someday, args.anyone)
            return
        
        # default action, list this user's items:
        self.listSprintlyItems(self._this_user())

    def _search_action(self, args):
        self.searchSprintlyItems(args.query, !args.omit_backlog, args.completed, args.someday, False, args.searchAll, args.searchComments)

    def _item_action(self, args):
        pid = str(self._config['product']['id'])
        
        if args.itemID:
            itemID = str(args.itemID)
            item = self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '.json')
            if item.get('code') and item['code'] != 200:
                self.cprint('This Item doesnt appear to exist')
                return
        else:
            itemID = None
            item = None
        
        if itemID and args.remove:
            if not itemID:
                self.cprint("Can't delete something that hasn't been created")
                return
            if self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '.json', delete=True):
                self.cprint('Successfully Removed Item ' + itemID)
            else:
                self.cprint('Failed to remove item ' + itemID)
            return

        updates = []
        if args.status:
            if args.status not in ITEM_STATUSES.keys():
                self.parser.print_help()
                return
            updates.append(('status', args.status))

        if args.size:
            if args.size not in ITEM_SCORES.keys():
                self.parser.print_help()
                return
            updates.append(('score', args.size))

        if args.title:
            updates.append(('title', args.title))

        if args.user:
            userID = self.getUserByEmail(args.user)
            if userID:
                updates.append(('assigned_to', userID))

        if type(args.description) in (str, unicode):
            updates.append(('description', args.description))

        elif args.description == True:
            if item and item['description'].strip():
                description = messageFromEditor(item['description'], replace=True)
            else:
                description = messageFromEditor('Description')

            if not description:
                self.cprint('No Description Entered')
            else:
                updates.append(('description', description))

        if args.tags:
            updates.append(('tags', args.tags))

        if args.parent:
            updates.append(('parent', args.parent))

        if not itemID:
            if args.type not in ('defect', 'test', 'task', 'story'):
                self.cprint('Unsupported type for a new item')
                self.parser.print_help()
                return
            updates.append(('type', args.type))

            if args.type == 'story':
                if not all([args.who, args.title, args.why]):
                    self.cprint('Missing Required Parameters For Story Type')
                    self.parser.print_help()
                    return
                updates.append(('who', args.who))
                updates.append(('what', args.title))
                # need to remove title:
                updates.remove(('title', args.title))
                updates.append(('why', args.why))
            
            resp = self.sprintlyAPICall('products/' + pid + '/items.json', updates)
            if not resp:
                self.cprint("Couldn't create the new item, check internet connection")
                return 
            
            itemID = str(resp['number'])

        else:
            self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '.json', updates)

        if args.comment or type(args.comment) in (str, unicode):
            if args.comment == True:
                comment = messageFromEditor('Comment')
            else:
                comment = args.comment
        
            if not comment:
                self.cprint('No Comment entered')
                return

            if self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '/comments.json', [('body', comment)]):
                self.cprint('Successfully Commented on Item ' + itemID)
            else:
                self.cprint('Failed to comment, check internet connection')
            return
        
        item = self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '.json')
        #print item

        color = ITEM_COLORS.get(item['type'])
        
        printItem = '''${%s}#%d${DEFAULT} (%s):${BOLD} %s${RESET}'''
        printAssignedTo = '''${DEFAULT}\tAssigned To: ${BOLD}%s${RESET}\n\tScore: ${BOLD}%s${RESET}\n'''
        
        if not item['assigned_to']:
            assigned_to = 'Unassigned'
        else:
            assigned_to = item['assigned_to']['first_name'] + ' ' + item['assigned_to']['last_name']

        self.cprint(printItem % (
            color, item['number'], ITEM_STATUSES[item['status']], item['title']
        ), trim=False)
        self.cprint(printAssignedTo % (
            assigned_to, ITEM_SCORES[item['score']]
        ))

        if len(item['description']):
            self.cprint('${UNDERLINE}${MAGENTA}Description:${RESET}${DEFAULT}')
            self.cprint('\t' + item['description'] + '\n', trim=False)
        
        if item['type'] == 'story':
            children = self.sprintlyAPICall('/products/' + pid + '/items/' + itemID + '/children.json')
            if len (children) > 0:
                self.cprint('${UNDERLINE}${MAGENTA}Children:${RESET}${DEFAULT}')
                products = [{'id': pid, 'items': children, 'name': 'Vadio'}]
                self.printItems(products, False)

        comments = self.sprintlyAPICall('products/' + pid + '/items/' + itemID + '/comments.json')
        if len(comments) > 0:
            self.cprint('${UNDERLINE}${MAGENTA}Comments:${RESET}${DEFAULT}')
            for comment in comments:
                name = comment['created_by']['first_name'] + ' ' + comment['created_by']['last_name']
                self.cprint('${DIM}%s${RESET}: %s' % (name, comment['body']), trim=False)


    def install(self, update):
        """
        Install this tool at SPRINTLY_PATH. If another file already
        exists with the same name, user will be prompted to replace the file.
        """

        print 'Grabbing TRE fuzzy regex package...'
        
        call(['wget', 'http://laurikari.net/tre/tre-0.8.0.tar.gz'])
        call(['wget', 'https://raw.github.com/laurikari/tre/master/python/tre-python.c'])
        call(['tar', '-xzvf', 'tre-0.8.0.tar.gz'])
        call(['mv', 'tre-python.c', './tre-0.8.0/python/'])
        os.chdir('./tre-0.8.0')
        call('./configure')
        call('make')
        call(['sudo', 'make', 'install'])
        os.chdir('./python')
        call(['sudo', 'python', 'setup.py', 'install'])
        os.chdir('../../')
        call(['sudo', 'rm', '-rf', './tre-0.8.0'])

        print 'Downloading latest version of sprintly from GitHub...'

        # get the file
        try:
            response = urllib2.urlopen(SPRINTLY_SOURCE_URL)
            sprintly_file_contents = response.read()
        except Exception:
            raise SprintlyException('Unable to obtain sprintly from %s' % SPRINTLY_SOURCE_URL)

        # verify nothing exists at the target path
        target = SPRINTLY_PATH
        if os.name == 'nt': target += '.py'
        if os.path.isfile(target):
            overwrite = raw_input(self.render('${BRIGHT_YELLOW}A file already exists at %s.${RESET} Overwrite file? ' % target, trim=False))
            while overwrite != 'y' and overwrite != 'n':
                overwrite = raw_input('Please enter y/n: ')

            if overwrite == 'n':
                self.cprint('Unable to install. Please install manually.', attr=RED)
                return

            # remove existing file
            print 'Deleting %s...' % target
            try:
                os.unlink(target)
            except Exception:
                raise SprintlyException('Unable to remove %s' % target)

        # copy file to target
        try:
            if not os.path.isdir(SPRINTLY_DIR):
                os.makedirs(SPRINTLY_DIR)
            target_file = open(target, 'w')
            target_file.write(sprintly_file_contents)
            target_file.close()
        except Exception:
            raise SprintlyException('Unable to save file to %s' % target)

        # ensure it is executable
        try:
            subprocess.call(['chmod', '+x', target])
        except Exception:
            raise SprintlyException('Unable to make %s executable.' % target)

        # done!
        self.cprint('Successfully installed sprintly to %s' % target, attr=GREEN)
        
        # if this is not an update, install
        if not update:
            print ''
            self.cprint('That\'s all! Type \'sprintly\' and hit enter to get started.', attr=BRIGHT_MAGENTA)
            print ''

    def initialize(self):
        """
        Ultimate goal is to get the user and key from the config file.
        If the config file cannot be found, a config file will be
        created via prompts displayed to the user. A cache file will
        also be created during this step.
        """

        # get the users home directory
        home = os.path.expanduser('~')
        if home == '~':
            raise SprintlyException('Unable to expand home directory.')

        # set the sprintly directory path (create if it doesn't exist)
        self._sprintlyDirectoryPath = os.path.join(home, '.sprintly')
        if not os.path.isdir(self._sprintlyDirectoryPath):
            os.mkdir(self._sprintlyDirectoryPath, 0700)
            if not os.path.isdir(self._sprintlyDirectoryPath):
                raise SprintlyException('Unable to create folder at %s' % self._sprintlyDirectoryPath)

        # set the sprintly config path (create if it doesn't exist)
        self._sprintlyConfigPath = os.path.join(self._sprintlyDirectoryPath, 'sprintly.config')
        if not os.path.isfile(self._sprintlyConfigPath):
            self.createSprintlyConfig()
        
        # load config values
        self.loadFromConfig()

    def createSprintlyConfig(self, update=False):
        """
        Create the Sprint.ly config. Prompt user for all necessary values.

        When 'update' is set to True and an existing value is present for
        a given configuration item, allow user to keep old value.

        Note: if update is True, this must be called after initialize. Failure
        to do so wil result in a new config being created, as the values in
        self._config will not yet be set.
        """

        if not update:
            print 'Creating config...'
        else:
            print 'Updating config... Press enter to accept default value shown in brackets.'

        # set version
        self._config['version'] = CONFIG_VERSION

        # used to simplify prompting user with optional default
        def getConfigItem(message, default=None):
            if default:
                item = raw_input(self.render('%s [${YELLOW}%s${RESET}]: ' % (message, default), trim=False)) or default
            else:
                item = raw_input('%s: ' % message)
            return item

        # prompt for user
        name = 'user'
        message = 'Enter Sprint.ly username (email)'
        if update and name in self._config:
            self._config[name] = getConfigItem(message, self._config[name])
        else:
            self._config[name] = getConfigItem(message)

        # prompt for key
        name = 'key'
        message = 'Enter Sprint.ly API Key'
        if update and name in self._config:
            self._config[name] = getConfigItem(message, self._config[name])
        else:
            self._config[name] = getConfigItem(message)

        # try and use API with these values to determine validity
        response = self.sprintlyAPICall('user/whoami.json')
        if not response or 'code' in response:
            raise SprintlyException('Invalid credentials. Unable to authenticate with Sprint.ly.')
        if response['email'] != self._config['user']:
            raise SprintlyException('Invalid credentials. Please ensure you are using your own API Key.')

        # add user id to config
        self._config['id'] = response['id']

        # get a list of products and prompt user for default product if more than 1
        products = self.sprintlyAPICall('products.json')
        if not products:
            raise SprintlyException('Unable to get product list.')
        productMap = {}

        for product in products:
            productId = str(product['id'])
            productMap[productId] = product

        productCount = len(productMap)

        if productCount == 0:
            raise SprintlyException('It appears that you have no products associated with your Sprint.ly account. Please add at least one and then try again.')
        elif productCount == 1:
            self._config['product'] = productMap.values()[0]
        else:
            # prompt user for a product until they enter one found in the map
            productList = ', '.join(['%d - %s' % (p['id'], p['name']) for p in productMap.values()])
            defaultProductId = '0'
            while defaultProductId not in productMap.keys():
                message = 'Enter default Sprint.ly product id (%s)' % productList
                if update and 'product' in self._config:
                    defaultProductId = getConfigItem(message, str(self._config['product']['id']))
                else:
                    defaultProductId = getConfigItem(message)
            self._config['product'] = productMap[defaultProductId]

        # write config file if all is good
        serialized_config = json.dumps(self._config)

        try:
            config_file = open(self._sprintlyConfigPath, 'w')
            config_file.write(serialized_config)
            config_file.close()
            if not update:
                self.cprint('Configuration successfully created.', attr=GREEN)
            else:
                self.cprint('Configuration successfully updated.', attr=GREEN)
        except:
            raise SprintlyException('Unable to write configuration to disk at %s' % self._sprintlyConfigPath)

    def loadFromConfig(self):
        """
        Load user and key from the config file. Validate here that the version
        of this config is readable by this version of the tool.
        """

        try:
            config_file = open(self._sprintlyConfigPath, 'r')
            serialized_config = config_file.readline()
            config_file.close()
            self._config = json.loads(serialized_config)
        except:
            raise SprintlyException('Unable to read credentials from disk at %s' % self._sprintlyConfigPath)

        # validate version
        if 'version' not in self._config or self._config['version'] != CONFIG_VERSION:
            self.cprint('Your configuration needs to be updated. You will now be prompted to update it.', attr=YELLOW)
            self.updateConfig()

    def updateConfig(self):
        """
        Prompt user to update configuration settings.
        Defaults will be original config values if present.
        """
        self.createSprintlyConfig(True)

    def listSprintlyUsers(self, byProducts=False):
        """
        Lists all Sprint.ly users by product.
        """
        data = self.getSprintlyUsers(byProducts)
        if not byProducts:
            self.printUserArray(data)
            return
        self.printUsersByProducts(data)

    def printUsersByProducts(self, products):
        """
        List users by the product they work on.
        """
        for product in products:
            users = product['users']
            productId = str(product['id'])
            productName = product['name']
            printProduct = '${DEFAULT}Product: ${BOLD}${BRIGHT_BLUE}' + productName + '${NORMAL}${GREY} (https://sprint.ly/product/' + productId + '/)'
            self.cprint(printProduct)
            
            for user in users:
                printUser = '${NORMAL}  ' + str(user['id']) + ': ${BOLD}${LIGHT_BLUE}' + user['first_name'] + ' ' + user['last_name'] + ' ${NORMAL}${GREY}(' + user['email'] + ')'
                self.cprint(printUser)
        self.cprint('')

    def printUserArray(self, users):
        """
        List all users from all products.
        """
        for user_id in users:
            user = users[user_id]
            printUser = '${NORMAL}' + str(user['id']) + ': ${BOLD}${LIGHT_BLUE}' + user['first_name'] + ' ' + user['last_name'] + ' ${NORMAL}${GREY}(' + user['email'] + ')'
            self.cprint(printUser)
        self.cprint('')

    def listSprintlyItems(self, userId = None, listBacklogItems=True,
                          listInProgress=True, listCompletedItems=False,
                          listSomedayItems=False, listAll=False):
        """
        Lists all items for the current user from the Sprint.ly API.
        listAll refers to all users, not all statuses.
        """
        data = self.getSprintlyItems(userId, listBacklogItems, listInProgress,
                                    listCompletedItems, listSomedayItems, False,
                                    limit=2000, listAll=listAll)
        self.printItems(data)

    def printItems(self, products, shouldPrintHeader=True, regex=None):
        """
        Print a list of Sprint.ly items.
        """
        
        statusTree = {
            'someday': {},
            'backlog': {},
            'in-progress': {},
            'completed': {},
            'accepted': {},
        }

        # An order that puts least viewed at the top and most viewed close
        # to the bottom close to the command line
        order = ['accepted', 'someday', 'completed', 'backlog', 'in-progress']

        for product in products:
            if 'items' in product:
                for item in product['items']:
                    # If the item has children, place it under child status
                    # instead of parent status. The parent will be listed under
                    # its own status along with any children w/ same status
                    productNotInTree = not product['id'] in statusTree[item['status']]
                    parentItem = 'children' in item
                    notParentItem = not parentItem
                    if notParentItem:
                        # Straight forward, just add to status of parent
                        if productNotInTree:
                            statusTree[item['status']][product['id']] = [item]
                        else:
                            statusTree[item['status']][product['id']].append(item)
                    else:
                        # If it has children, it should be placed under the
                        # status of the children.
                        children = item['children']
                        first_child = children[0]
                        childStatus = first_child['status']
                        if not product['id'] in statusTree[childStatus]:
                            statusTree[childStatus][product['id']] = []
                        statusTree[childStatus][product['id']].append(item)

        for key in order:
            status = statusTree[key]
            if not len(status):
                continue

            self.cprint(ITEM_STATUSES[key], attr=[BRIGHT_MAGENTA, UNDERLINE])

            for product_id in status:
                items = status[product_id]
                name = items[0]['product']['name']
                productId = str(items[0]['product']['id'])
                
                if shouldPrintHeader:
                    printProduct = '${DEFAULT}Product: ${BOLD}${BRIGHT_BLUE}' + name + '${NORMAL}${GREY} (https://sprint.ly/product/' + productId + '/)'
                    self.cprint(printProduct)

                for item in items:
                    if not item['assigned_to']:
                        assigned_to = '(Unassigned)'
                    else:
                        assigned_to = '(' + item['assigned_to']['first_name'] + ' ' + item['assigned_to']['last_name'] + ')'

                    attr = None
                    if item['status'] != key:
                        attr = DIM
                    color = ITEM_COLORS.get(item['type'])

                    title = item['title']
                    if regex:
                        title = getHighlightedStr(title, regex)
                    
                    printItem = '${%s}%-6s${DEFAULT}     %18s:  ${DEFAULT}%s' % (
                        color, '#' + str(item['number']), assigned_to, title
                    )
                    self.cprint(printItem, attr=attr)

                    if 'children' in item:
                        for child in item['children']:
                            attr = None
                            childColor = ITEM_COLORS.get(child['type'])
                            title = child['title']
                            if regex:
                                title = getHighlightedStr(title, regex)
                            
                            if not child['assigned_to']:
                                assigned_to = '(Unassigned)'
                            else:
                                assigned_to = '(' + child['assigned_to']['first_name'] + ' ' + child['assigned_to']['last_name'] + ')'

                            printChild = u'${%s}   %-6s${DEFAULT}  %18s:  ${DEFAULT}%s' % (
                                childColor, '#' + str(child['number']), assigned_to, title
                            )
                            self.cprint(printChild, attr=attr)

            self.cprint('')


    def searchSprintlyItems(self, query, backlog=True, completed=False, someday=False, fromServer=False, searchAny=False, searchComments=False):
        """ Searches sprintly for items that match in the description or title
            TODO Optionally will search comments as well for results
        """
        products = self.getSprintlyProducts(fromServer)
        t_data = []
        
        pat = tre.compile(query, tre.EXTENDED | tre.ICASE)
        fuz = None
        if len(query) < 4:
            fuz = FUZ0
        elif len(query) < 8:
            fuz = FUZ1
        else:
            fuz = FUZ2
        
        def filterList(item):
            if pat.search(item['title'], fuz) or pat.search(item['description'], fuz):
                return True
            if item.get('children'):
                for cItem in item['children']:
                    if pat.search(cItem['title'], fuz) or pat.search(cItem['description'], fuz):
                        return True
            return False
        
        t_data.append(self._getSprintlyItemsCore(None, status='in-progress', assoc=True, getProductsFromServer=fromServer, listAll=True))

        if backlog or searchAny:
            t_data.append(self._getSprintlyItemsCore(None, status='backlog', assoc=True, getProductsFromServer=fromServer, listAll=True))

        if completed or searchAny:
            t_data.append(self._getSprintlyItemsCore(None, status='completed', assoc=True, getProductsFromServer=fromServer, listAll=True))

        if someday or searchAny:
            t_data.append(self._getSprintlyItemsCore(None, status='someday', assoc=True, getProductsFromServer=fromServer, listAll=True))

        for product in products:
            if 'items' not in product:
                product['items'] = []
                
        for product in products:
            for data in t_data:
                if not data or not str(product['id']) in data:
                    continue
                product['items'] = product['items'] + filter(filterList, data[str(product['id'])]['items'])

        self.printItems(products, regex=(pat, fuz))
                    
            
    def getSprintlyItems(self, userId=None, listBacklogItems=True, listInProgress=True,
                         listCompletedItems=False, listSomedayItems=False,
                         getProductsFromServer=False, limit=100, listAll=False):
        """
        Get all Sprint.ly items. By default gets them for local user, but can
        also retrieve for other users when given a user ID.
        listAll refers to all users, not all statuses.
        """
        
        if userId:
            userId = self.getUserByEmail(userId)
        
        products = self.getSprintlyProducts(getProductsFromServer)
        t_data = []
        
        if not userId:
            print '\033[91m'
            print 'No user selected. Showing unassigned. (user: "' + str(userId) + '")'
            print '\033[0m'
        
        if listInProgress:
            t_data.append(self._getSprintlyItemsCore(userId, status='in-progress',
                                                     limit=limit, assoc=True,
                                                     getProductsFromServer=getProductsFromServer,
                                                     listAll=listAll))
        
        if listBacklogItems:
            t_data.append(self._getSprintlyItemsCore(userId, status='backlog',
                                                     limit=limit, assoc=True,
                                                     getProductsFromServer=getProductsFromServer,
                                                     listAll=listAll))
        
        if listCompletedItems:
            t_data.append(self._getSprintlyItemsCore(userId, status='completed',
                                                     limit=limit, assoc=True,
                                                     getProductsFromServer=getProductsFromServer,
                                                     listAll=listAll))
        
        if listSomedayItems:
            t_data.append(self._getSprintlyItemsCore(userId, status='someday',
                                                     limit=limit, assoc=True,
                                                     getProductsFromServer=getProductsFromServer,
                                                     listAll=listAll))
        
        for product in products:
            for data in t_data:
                if data:
                    if str(product['id']) in data:
                        if 'items' not in product:
                            product['items'] = []
                        product['items'] = product['items'] + data[str(product['id'])]['items']
        return products

    def _getSprintlyItemsCore(self, userId=None, status=None, limit=100, getProductsFromServer=False, assoc=False, listAll=False):
        """
        Get Sprint.ly items. By default, just in-progress and backlog items are
        listed. Specify a status to limit to that status. pass assoc=True to 
        get an associative array back linking product IDs to products, rather
        than the default array of products.
        """
        
        if status != None:
            status = '&status=' + status
        else:
            status = ''
        
        data = None
        if assoc:
            data = {}
        else:
            data = []
        products = self.getSprintlyProducts(getProductsFromServer)
        
        try:
            assigned_to = ''
            if not listAll:
                assigned_to = '&assigned_to=' + str(userId)
                if not userId:
                    assigned_to = '&assigned_to=0'
            
            # iterate over products
            for product in products:
                
                productName = product['name']
                productId = str(product['id'])
                
                items = []
                offset = 0
                while True:
                    
                    itemsPartial = self.sprintlyAPICall('products/' + productId + '/items.json?children=1' + assigned_to + status + '&limit=' + str(limit) + '&offset=' + str(offset))

                    # if we get nothing, an empty list, an error, quit
                    if not itemsPartial or len(itemsPartial) == 0 or 'code' in itemsPartial:
                        break
                    # otherwise, add on these items and increase the offset
                    else:
                        items = items + itemsPartial
                        offset = offset + limit

                    # if we got less than a full response, no need to check again
                    if len(itemsPartial) < limit:
                        break

                # if anything went wrong, print an error message
                if 'code' in items:
                    # include message if applicable
                    message = ''
                    if 'message' in items:
                        message = ': %s' % items['message']
                    productNameWithUrl = '\'' + productName + '\' (https://sprint.ly/product/' + productId + '/)'
                    print 'Warning: unable to get items for %s%s' % (productNameWithUrl, message)
                    continue
                # if there are no items, display message
                elif len(items) == 0:
                    productNameWithUrl = '\'' + productName + '\' (https://sprint.ly/product/' + productId + '/)'
                    print 'No assigned items for %s' % (productNameWithUrl)
                
                # a 'parent' is any item without a parent key
                # a 'child' is any item with a parent key
                # sort so that all parents appear first and all children appear after ordered by their number
                items.sort(key=lambda item: item['number'] if 'parent' in item else sys.maxint, reverse=True)

                # turn flat list into tree
                itemsTree = []
                parentMapping = {} # allow parents to be looked up by number

                for item in items:
                    number = str(item['number'])

                    # if item is not a child
                    if 'parent' not in item:
                        itemsTree.append(item)
                        parentMapping[number] = item

                    # if item is a child...
                    else:
                        parent = item['parent']  # get reference to parent
                        del item['parent']  # remove parent from child
                        parentNumber = str(parent['number'])

                        # if we have the parent, nest under parent
                        if parentNumber in parentMapping:

                            # we sorted items above to ensure all parents will be in map before any child is encountered
                            parent = parentMapping[parentNumber]
                            if 'children' not in parent:
                                parent['children'] = []
                            parent['children'].append(item)

                        # if we don't have the parent, add placeholder parent to preserve tree structure
                        else:
                            parent['children'] = [item]
                            parentMapping[parentNumber] = parent
                            itemsTree.append(parent)
                
                # sort items by (status, then first child, if it exists, else number)
                itemsTree.sort(key=lambda item: item['children'][0]['number'] if 'children' in item else item['number'], reverse=True)
                product['items'] = itemsTree
                
                if assoc:
                    data[productId] = product
                else:
                    data.append(product)
            
            return data

        except Exception as ex:
            print '\033[91m'
            print 'Unable to get sprintly data. (exception: ' + str(ex) + ')'
            print '\033[0m'
            traceback.print_exc()
            return None

    def getSprintlyProducts(self, fromServer=False):
        """
        Get array of sprintly products. By default, just grabs locally from
        config file.
        """
        products = []
        # get products from the API
        if fromServer:
            products = self.sprintlyAPICall('products.json')
            if not products:
              raise SprintlyException('Unable to get product list.')
        else:
            # copy product from config file
            product = {'name': self._config['product']['name'],
                       'id': self._config['product']['id']};
            products.append(product)
        return products

    def getUserByEmail(self, email):
        """ Gets a single user id using the email string as the
            string to match against """
        if type(email) == int or re.search('^\d+$', email):
            return int(email)
        
        users = self.getSprintlyUsers()
        acceptable = []
        for userID, data in users.items():
            if re.search(email, str(data['email']), re.I | re.S):
                acceptable.append((userID, data))

        valid = []
        if len(acceptable) == 1:
            return acceptable[0][0]

        elif len(acceptable) > 1:
            self.cprint('${BRIGHT_YELLOW}Multiple users exist for that re please select an ID from below:${RESET}')
            for user in acceptable:
                valid.append(str(user[0]))
                printUser = '${NORMAL}  ' + str(user[0]) + ': ${BOLD}${LIGHT_BLUE}' + user[1]['first_name'] + ' ' + user[1]['last_name'] + ' ${NORMAL}${GREY}(' + user[1]['email'] + ')'
                self.cprint(printUser)

            uid = raw_input(self.render('${BRIGHT_YELLOW}Which User ID:${RESET} ', trim=False))
            
            while uid not in valid:
                uid = raw_input('Please enter a valid user ID from above: ')

            return int(uid)

        else:
            self.cprint('${BRIGHT_YELLOW}No users exist for that re please select an ID from below or -1 for no user:${RESET}')
            
            for user in users.items():
                valid.append(str(user[0]))
                printUser = '${NORMAL}  ' + str(user[0]) + ': ${BOLD}${LIGHT_BLUE}' + user[1]['first_name'] + ' ' + user[1]['last_name'] + ' ${NORMAL}${GREY}(' + user[1]['email'] + ')'
                self.cprint(printUser)

            valid.append('-1')
            uid = raw_input(self.render('${BRIGHT_YELLOW}Which User ID:${RESET} ', trim=False))
            
            while uid not in valid:
                uid = raw_input('Please enter a valid user ID from above: ')

            if uid == '-1':
                return None
            return int(uid)
                        
    def getSprintlyUsers(self, byProducts=False):
        """
        Get all Sprint.ly users.
        
        If byProducts == True, returns an array of
        products: [{name:string, id:number, users:[]}, ...]
        
        If byProducts == False, returns an assoc array of
        users: {<user_id>: {admin: bool, first_name: string, last_name: string,
                 id: number, email: string}, ...}
        """
        try:
            products = []
            users = {}
            
            # use product from config file
            products.append(self._config['product'])
            
            # get products from the API
            # products = self.sprintlyAPICall('products.json')
            # if not products:
            #   raise SprintlyException('Unable to get product list.')
            
            # iterate over products
            for product in products:
                productName = product['name']
                productId = str(product['id'])
                product['users'] = self.sprintlyAPICall('products/' + productId + '/people.json')
                
                # iterate over users adding to global user array
                for user in product['users']:
                    users[user['id']] = user
            
            if byProducts:
                return products
            return users
            
        except Exception as ex:
            print '\033[91m'
            print 'Unable to get sprintly data. (exception: ' + str(ex) + ')'
            print '\033[0m'
            return None

    def sprintlyAPICall(self, url, data=None, delete=False):
        """
        Wraps up a call to the Sprint.ly api. Returns a map representing
        the JSON response or false if the call could not be completed.
        @param (list|tuple of 2-tuples) data - Data to be passed as post to server
        @param (bool) delete - Whether to send as a DELETE method
        """

        url = 'https://sprint.ly/api/%s' % url

        try:
            userData = 'Basic ' + (self._config['user'] + ':' + self._config['key']).encode('base64').replace("\n",'')
            opener = urllib2.build_opener(urllib2.HTTPHandler)
            
            if data:
                data = urllib.urlencode(data)
            
            req = urllib2.Request(url, data=data)
            req.add_header('Accept', 'application/json')
            req.add_header('Authorization', userData)

            if delete:
                req.get_method = lambda: 'DELETE'

            res = opener.open(req)
            
            response = res.read()
            return json.loads(response)
        except urllib2.HTTPError, error:
            response = error.read()
            return json.loads(response)
        except Exception:
            return False
    
    def cprint(self, str, attr=None, trim=True):
        self._term.write(self.render(str, attr, trim) + '\r\n')

    def render(self, str, attr=None, trim=True):
        if self._has_color:
            if attr:
                if isinstance(attr, list):
                    attr = ''.join(attr)
            else:
                attr = ''

            seq = re.sub(r'\$\$|\${\w+}', self._render_sub, str)
            if trim:
                seq = self._trim(seq)

            return attr + seq + RESET
        else:
            seq = re.sub(r'\$\$|\${\w+}', '', str)
            if trim and len(seq) > self._cols:
                return seq[0:self._cols - 1] + u'\u2026'
            return seq

    def _render_sub(self, match):
        s = match.group()
        if s == '$$':
            return s
        else:
            return ATTRS.get(s[2:-1], '')

    def _trim(self, raw):
        # TODO: >>> This could probably be much simpler if I was smarter
        seq = ''
        str_len = 0
        i = 0
        matchiter = re.finditer(r'(\x1b.*?m)', raw.strip())
        for match in matchiter:
            chunk = raw[i:match.start()]
            i = match.end()
            if str_len + len(chunk) > self._cols:
                chunk = chunk[0:self._cols - str_len - 1] + u'\u2026'
            str_len = str_len + len(chunk)
            seq = seq + chunk + match.group()

            if (str_len >= self._cols):
                break

        if str_len < self._cols:
            chunk = raw[i:]
            if str_len + len(chunk) > self._cols:
                chunk = chunk[0:self._cols - str_len - 1] + u'\u2026'
            seq = seq + chunk

        return seq

    def elipsify(self, seq):
        return seq[0:-1].strip(string.punctuation) + u'\u2026'

    def _this_user(self):
        if not 'id' in self._config:
            return None
        return self._config['id']


class SprintlyException(Exception):
    """
    Exception used to pass known exceptions throughout
    the sprintly tool.
    """
    def __init__(self, value):
        self.value = value

    def __str__(self):
        return repr(self.value)


def die(message=None, *args):
    """
    Prints the message, if present, and then exits.
    """

    if message:
        logger.error(message, *args, exc_info=True)
    print 'Program exiting.'
    sys.exit(1)

def _get_terminal_size_windows():
    try:
        from ctypes import windll, create_string_buffer
        # stdin handle is -10
        # stdout handle is -11
        # stderr handle is -12
        h = windll.kernel32.GetStdHandle(-12)
        csbi = create_string_buffer(22)
        res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)
        if res:
            (bufx, bufy, curx, cury, wattr,
            left, top, right, bottom,
            maxx, maxy) = struct.unpack("hhhhHhhhhhh", csbi.raw)
            sizex = right - left + 1
            sizey = bottom - top + 1
            return sizex, sizey
    except:
        pass

if __name__ == '__main__':
    sprintlyTool = SprintlyTool()
    sprintlyTool.run()
